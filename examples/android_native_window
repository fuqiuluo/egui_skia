mod egui_skia;
mod fonts;
mod painter;

use crate::egui_skia::{RasterizeOptions, rasterize};
use crate::fonts::setup_fonts;
use clap::Parser;
use egui::{RawInput, pos2, vec2, Rect, Color32};
use epaint::{ImageData, PathStroke};
use esp::driver::wuwa::WuWaDriver;
use esp::graphics::GraphicsInterface;
use esp::native_window::NativeWindow;
use esp::native_window::ffi::{*};
use esp::{Condition, ConfigFlags, Context, Io};
use log::{Level, debug, error, info, log_enabled};
use skia_safe::{AlphaType, ColorType, ImageInfo, Paint, Point};
use std::fmt::format;
use std::process::exit;
use std::ptr;
use std::time::{Duration, Instant};

#[derive(Parser, Debug)]
#[command(about = "fuqiuluo's DFM")]
struct Args {
    #[arg(short = 'v', long = "verbose")]
    verbose: bool,
    #[arg(short = 'b', long = "background")]
    background: bool,
    #[arg(short = 'e', long = "renderer", default_value = "vulkan")]
    renderer: String,
    #[arg(long = "fps", default_value_t = 60.0)]
    fps: f32,
}

fn main() -> anyhow::Result<()> {
    let args = Args::parse();
    if args.verbose {
        unsafe {
            std::env::set_var("RUST_LOG", "debug");
        }
    }

    env_logger::init();

    if args.background {
        info!("即将进入后台运行，这是可见的最后一条日志");
        if unsafe { libc::daemon(0, 0) } != 0 {
            error!("无法进入后台运行");
            exit(1);
        }
    }

    if args.verbose {
        info!("命令行参数: {:?}", args);
        let current_dir = std::env::current_dir()?;
        info!("当前工作目录: {}", current_dir.display());
        let exe_path = std::env::current_exe()?;
        let metadata = std::fs::metadata(&exe_path)?;
        info!(
            "当前可执行文件: {} (大小: {} 字节)",
            exe_path.display(),
            metadata.len()
        );
    }

    let (screen_x, screen_y) = NativeWindow::get_abs_screen();
    let mut native_window = NativeWindow::new("DFM", screen_x, screen_y, false);
    if log_enabled!(Level::Debug) {
        debug!("创建原生窗口: {:?}", native_window);
    }

    let window = native_window.native_window;

    unsafe { ANativeWindow_acquire(window) };
    let width = unsafe { ANativeWindow_getWidth(window) } as u32;
    let height = unsafe { ANativeWindow_getHeight(window) } as u32;
    const  WINDOW_FORMAT_RGBA8888: i32 = 1;
    let r = unsafe {
        ANativeWindow_setBuffersGeometry(
            window,
            width as i32,
            height as i32,
            WINDOW_FORMAT_RGBA8888,
        )
    };

    use std::time::{Duration, Instant};

    // 初始化帧率计算变量
    let mut frame_times = Vec::with_capacity(60); // 保存最近60帧的时间
    let mut last_frame_time = Instant::now();
    let mut fps = 0.0;

    loop {
        // 计算帧时间
        let now = Instant::now();
        let delta_time = now.duration_since(last_frame_time);
        last_frame_time = now;

        // 更新帧时间记录
        frame_times.push(delta_time);
        if frame_times.len() > 60 {
            frame_times.remove(0);
        }

        // 计算平均帧率（使用最近60帧的移动平均）
        let total_time: Duration = frame_times.iter().sum();
        if !total_time.is_zero() {
            fps = frame_times.len() as f32 / total_time.as_secs_f32();
        }

        let mut surface = rasterize(
            (screen_x, screen_y),
            |ctx| {
                let mut style = (*ctx.style()).clone();
                style.visuals.panel_fill = Color32::TRANSPARENT;
                ctx.set_style(style);

                egui::CentralPanel::default()
                    .frame(egui::Frame::new().fill(Color32::from_rgba_premultiplied(0x80, 0x55, 0x55, 0x55)))
                    .show(ctx, |ui| {
                        ui.heading("Hello, World!");
                        ui.heading(format!("Hello, World!: {:?}", Instant::now()));

                        // FPS信息添加半透明背景
                        ui.group(|ui| {
                            ui.visuals_mut().widgets.noninteractive.bg_fill = Color32::BLACK;
                            ui.visuals_mut().widgets.noninteractive.bg_stroke = egui::Stroke::NONE;

                            ui.colored_label(egui::Color32::WHITE, format!("FPS: {:.1}", fps));
                            ui.colored_label(
                                egui::Color32::WHITE,
                                format!("Frame Time: {:.2} ms", delta_time.as_secs_f64() * 1000.0),
                            );
                        });

                        if ui.button("Click me").clicked() {
                            println!("Button clicked!");
                        }
                    });
            },
            Some(RasterizeOptions {
                pixels_per_point: 2.0,
                frames_before_screenshot: 2,
            }),
        );

        unsafe {
            if let Err(e) = blit_surface_to_window(&mut surface, window) {
                error!("{}", e);
            }

        }
    }

    Ok(())
}

#[repr(C)]
pub struct ANativeWindow_Buffer {
    pub width: i32,
    pub height: i32,
    pub stride: i32,
    pub format: i32,
    pub bits: *mut std::ffi::c_void,
    pub reserved: [u32; 6],
}

pub unsafe fn blit_surface_to_window(surface: &mut skia_safe::Surface, window: *mut ANativeWindow) -> Result<(), &'static str> {
    if window.is_null() {
        return Err("window is null");
    }

    // 取得 surface 尺寸
    let sw = surface.width();
    let sh = surface.height();

    // 目标格式设为 RGBA8888
    let info = ImageInfo::new(
        skia_safe::ISize::new(sw, sh),
        ColorType::RGBA8888,
        AlphaType::Premul,
        None,
    );

    let bytes_per_pixel = 4usize;
    let src_row_bytes = sw as usize * bytes_per_pixel;
    let mut buffer_rgba = vec![0u8; src_row_bytes * sh as usize];

    // 读取像素
    let ok = surface.read_pixels(
        &info,
        &mut buffer_rgba,
        src_row_bytes,
        (0, 0),
    );
    if !ok {
        return Err("read_pixels failed");
    }

    // 锁窗口
    let mut win_buf: ANativeWindow_Buffer = std::mem::zeroed();
    if ANativeWindow_lock(window, &mut win_buf as *mut _ as *mut _, ptr::null_mut()) != 0 {
        return Err("ANativeWindow_lock failed");
    }

    let dst_ptr = win_buf.bits as *mut u8;
    if dst_ptr.is_null() {
        // 解锁（即使空）
        ANativeWindow_unlockAndPost(window);
        return Err("window bits is null");
    }

    // stride 是以像素为单位
    let dst_stride_pixels = win_buf.stride as usize;
    let dst_stride_bytes = dst_stride_pixels * bytes_per_pixel;

    let copy_width_pixels = sw.min(win_buf.width);
    let copy_height_pixels = sh.min(win_buf.height);

    let copy_bytes_per_row = copy_width_pixels as usize * bytes_per_pixel;

    for y in 0..(copy_height_pixels as usize) {
        let src_row = &buffer_rgba[y * src_row_bytes .. y * src_row_bytes + copy_bytes_per_row];
        let dst_row_ptr = dst_ptr.add(y * dst_stride_bytes);
        ptr::copy_nonoverlapping(src_row.as_ptr(), dst_row_ptr, copy_bytes_per_row);
    }

    ANativeWindow_unlockAndPost(window);

    Ok(())
}
